use base64::engine::general_purpose::STANDARD;
use base64::Engine;
use crc::{Algorithm, Crc};
use nmea::sentences::GgaData;
use nmea::ParseResult;
use regex::Regex;
use std::io;
use std::io::{BufReader, ErrorKind, Read, Write};
use std::net::TcpStream;
use std::time::Duration;

/// # Explanation
/// The ntrip client struct is used to create requests to a ntrip caster. For this the (ip) address of
/// the caster is required as well as the port. Furthermore, a mountpoint, an username and a password is required.
///
/// The ntrip client first sends a http header to authenticate itself. Then with the open socket a
/// gga-sentence is sent and the caster then sends back the rtcm data (correction data).
pub struct NtripClient {
    addr: String,
    port: u16,
    mountpoint: String,
    username: String,
    password: String,
}

impl NtripClient {
    const MAX_READ_SIZE: u64 = 65536;

    pub fn new(
        addr: String,
        port: u16,
        mountpoint: String,
        username: String,
        password: String,
    ) -> Self {
        NtripClient {
            addr,
            port,
            mountpoint,
            username,
            password,
        }
    }

    /// # Explanation
    /// This function creates a connection with the ntrip caster and then retrieves the correction data
    /// from it.
    pub fn get_correction(&self, message: &str) -> io::Result<Vec<Vec<u8>>> {
        // profile here. maybe dont create a new connection every time?
        let mut stream = TcpStream::connect(format!("{}:{}", self.addr, self.port))?;
        stream.set_read_timeout(Some(Duration::from_secs(10)))?;
        stream.set_write_timeout(Some(Duration::from_secs(10)))?;

        let request = self.create_request();
        stream.write_all(request.as_bytes())?;

        if Self::is_header_ok(&mut stream)? {
            log::trace!("The connection to the ntrip caster is established.");

            let rtcm_data = Self::read_rtcm(&mut stream, message)?;
            log::trace!("The received rtcm data is {:?}.", rtcm_data);
            Ok(rtcm_data)
        } else {
            Err(io::Error::new(
                ErrorKind::ConnectionRefused,
                "Response did not start with HTTP OK.",
            ))
        }
    }

    fn create_request(&self) -> String {
        format!(
            "GET /{} HTTP/1.1\r\n\
            User-Agent: {}\r\n\
            Host: {}:{}\r\n\
            Ntrip-Version: Ntrip/2.0\r\n\
            Authorization: Basic {}\r\n\r\n",
            self.mountpoint,
            self.username,
            self.addr,
            self.port,
            STANDARD.encode(format!("{}:{}", self.username, self.password))
        )
    }

    /// # Explanation
    /// Check if the response of the caster consists of a HTTP-OK header (status code 200).
    fn is_header_ok(stream: &mut TcpStream) -> io::Result<bool> {
        let mut header = vec![];
        Self::read_all_available(stream, &mut header)?;
        let header = String::from_utf8(header).unwrap();

        Ok(header.starts_with("HTTP/1.1 200"))
    }

    /// # Explnation
    /// After authentication a gga-sentence can be sent to the caster.
    /// The returned data then is the rtcm data.
    fn read_rtcm(stream: &mut TcpStream, message: &str) -> io::Result<Vec<Vec<u8>>> {
        if is_gga_sentence(message) {
            stream.write_all(message.as_bytes())?;

            let mut rtcm_buf = vec![];
            Self::read_all_available(stream, &mut rtcm_buf)?;
            Ok(Self::extract_rtcm_messages(rtcm_buf))
        } else {
            Ok(vec![])
        }
    }

    fn read_all_available(stream: &TcpStream, buf: &mut Vec<u8>) -> io::Result<()> {
        let mut reader = BufReader::new(stream).take(Self::MAX_READ_SIZE);

        const BLOCK_SIZE: usize = 1024;
        let mut bytes_read = BLOCK_SIZE;
        let mut intermediate_buf = [0u8; BLOCK_SIZE];
        while bytes_read == BLOCK_SIZE {
            bytes_read = reader.read(&mut intermediate_buf)?;
            buf.extend_from_slice(&intermediate_buf[0..bytes_read]);
        }

        Ok(())
    }

    /// # Explanation
    /// Searches for all rtcm messages in the given buffer and returns them (the buffer can contain data
    /// in between).
    pub fn extract_rtcm_messages(buf: Vec<u8>) -> Vec<Vec<u8>> {
        let mut rtcm_messages = vec![];
        let mut current_buf = buf;

        while let Some((rtcm_message, left_over)) = Self::find_first_rtcm_msg(current_buf) {
            rtcm_messages.push(rtcm_message);
            current_buf = left_over;
        }

        rtcm_messages
    }

    /// # Explanation
    /// This function finds the first rtcm message in the buffer. Then this rtcm message is returned, as well
    /// as the elements to the right of the rtcm message.
    fn find_first_rtcm_msg(buf: Vec<u8>) -> Option<(Vec<u8>, Vec<u8>)> {
        let mut current_buf = buf;

        for index in 0..current_buf.len() {
            if let Some(rtcm_msg_size) = Self::is_valid_rtcm_from_start(&current_buf[index..]) {
                let left_over = current_buf.split_off(index + rtcm_msg_size);
                let rtcm_message = current_buf.split_off(index);
                return Some((rtcm_message, left_over));
            }
        }

        None
    }

    /// # Explanation
    /// This function returns the size of the rtcm message that starts at index 0.
    fn is_valid_rtcm_from_start(buf: &[u8]) -> Option<usize> {
        if buf.len() < 3 || buf[0] != 0xD3 {
            return None;
        }

        let length = u16::from_be_bytes([buf[1], buf[2]]);
        let msg_size: usize = 6 + length as usize; // 1 byte for preamble, 2 bytes for the length, 3 byte for crc

        if buf.len() < msg_size {
            return None;
        }

        const CRC24Q: Algorithm<u32> = Algorithm {
            width: 24,
            poly: 0x1864CFB,
            init: 0x0,
            refin: false,
            refout: false,
            xorout: 0x0,
            check: 0xCDE703,
            residue: 0x0,
        };
        let crc_algorithm = Crc::<u32>::new(&CRC24Q);

        if crc_algorithm.checksum(&buf[0..msg_size]) == 0 {
            Some(msg_size)
        } else {
            None
        }
    }
}

/// # Explanation
/// This function returns the nmea GGA sentence that is in the given string (if present).
pub fn extract_gga_sentence(s: &str) -> Option<String> {
    let re = Regex::new(r"\$.{0,2}GGA.{0,200}\r\n").unwrap();
    re.find(&s).map(|gga_match| gga_match.as_str().to_string())
}

/// # Explanation
/// Parses the given string to GgaData. Keep in mind, that the given string must begin and end with
/// the GGA sentence (the sentence can not be in the middle).
pub fn parse_to_gga(s: &str) -> Option<GgaData> {
    let parse_result = nmea::parse_str(s);
    match parse_result {
        Ok(ParseResult::GGA(gga_sentence)) => Some(gga_sentence),
        _ => None,
    }
}

pub fn is_gga_sentence(s: &str) -> bool {
    parse_to_gga(s).is_some()
}

#[cfg(test)]
mod tests {
    use crate::sensor_utils::gps_utils;
    use crate::sensor_utils::gps_utils::NtripClient;

    #[test]
    fn test_extract_gga() {
        let sentence =
            "$GNRMC,185823.40,A,4808.7402374,N,01133.9324760,E,0.00,112.64,130117,3.00,E,A*14\r\n";
        assert!(gps_utils::extract_gga_sentence(sentence).is_none());

        let sentence = "$GPGGA,123519,4807.038,N,01131.000,E,1,08,0.9,545.4,M,46.9,M,,*47\r\n";
        assert!(gps_utils::extract_gga_sentence(sentence).is_some());

        let sentence = "abcdefg";
        assert!(gps_utils::extract_gga_sentence(sentence).is_none());

        let sentence = "$GNGGA,123519.00,4807.038,N,01131.000,E,1,08,0.9,545.4,M,46.9,M,,*77\r\n\
                             $GNRMC,185823.40,A,4808.7402374,N,01133.9324760,E,0.00,112.64,130117,3.00,E,A*14\r\n";
        assert!(gps_utils::extract_gga_sentence(sentence).is_some());

        let sentence = "$GNRMC,185823.40,A,4808.7402374,N,01133.9324760,E,0.00,112.64,130117,3.00,E,A*14\r\n\
                             $GNGGA,123519.00,4807.038,N,01131.000,E,1,08,0.9,545.4,M,46.9,M,,*77\r\n";
        assert!(gps_utils::extract_gga_sentence(sentence).is_some());

        let sentence = "$GNRMC,202521.36,V,,,,,,,090823,,,N,V*1A\r\n";
        assert!(gps_utils::extract_gga_sentence(sentence).is_none());
    }

    #[test]
    fn test_is_valid_rtcm() {
        let rtcm_msg = [
            0xd3, 0x0, 0xe2, 0x43, 0x2b, 0x6f, 0x5d, 0x8f, 0xb8, 0xa2, 0x0, 0x20, 0x8f, 0x50, 0x88,
            0x2, 0x0, 0x0, 0x0, 0x0, 0x20, 0x20, 0x81, 0x0, 0x7f, 0x7f, 0x7f, 0xe6, 0x7a, 0x82,
            0x6a, 0x6a, 0x2a, 0x42, 0x4a, 0x82, 0x2a, 0x41, 0xa8, 0xa7, 0xcc, 0xff, 0x51, 0x66,
            0x80, 0xba, 0xdc, 0xc7, 0x67, 0xf6, 0x3f, 0xf4, 0x97, 0xea, 0xaf, 0xea, 0x9e, 0x32,
            0x7c, 0x5b, 0xf8, 0xe7, 0xde, 0x87, 0xc2, 0x4f, 0x86, 0x77, 0xc, 0xb3, 0xe8, 0xe7,
            0xc7, 0xcf, 0x9a, 0xfe, 0xdf, 0xfe, 0xed, 0xfe, 0x33, 0xfc, 0xe, 0x80, 0x3c, 0xfe,
            0x9a, 0x4, 0xf4, 0x6c, 0x7c, 0xa6, 0xfa, 0x49, 0xd3, 0x37, 0xa5, 0x60, 0x21, 0x40,
            0x51, 0x20, 0xad, 0x41, 0x45, 0xff, 0x65, 0xf1, 0xfe, 0x90, 0x3f, 0xfa, 0x3f, 0xdf,
            0xf4, 0xc0, 0xfe, 0x32, 0x15, 0xf8, 0xb5, 0x17, 0xe2, 0xd4, 0x7e, 0xf4, 0xc, 0xfc,
            0x24, 0x4d, 0xf0, 0x91, 0x17, 0xc3, 0x10, 0xc1, 0xf4, 0x19, 0x7, 0xc8, 0xc8, 0x1f,
            0x23, 0x5f, 0xfb, 0x74, 0xff, 0xf7, 0x26, 0x7f, 0xdc, 0x93, 0xff, 0x83, 0x7, 0xa0,
            0x12, 0xfe, 0x7f, 0x1f, 0x79, 0xfc, 0x7d, 0xe8, 0xd7, 0xe7, 0xf2, 0x83, 0xbf, 0xd2,
            0x2c, 0x7d, 0x34, 0x67, 0xf4, 0xaa, 0xa0, 0x8, 0x45, 0x40, 0x28, 0x57, 0x0, 0xa1, 0x6e,
            0x2, 0x86, 0xea, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
            0xaa, 0xaa, 0xaa, 0xa8, 0x0, 0x0, 0x0, 0x15, 0xb7, 0x3c, 0xf7, 0x41, 0x3d, 0xb5, 0xd5,
            0x7e, 0x19, 0xdd, 0x86, 0x56, 0xe9, 0x84, 0xb6, 0xe5, 0x42, 0x97, 0xcd, 0x8e, 0x56,
            0xe6, 0x78, 0xa6, 0xb9,
        ];
        assert_eq!(NtripClient::is_valid_rtcm_from_start(&rtcm_msg), Some(232));

        let rtcm_msg = [
            0xd3, 0x0, 0x8a, 0x43, 0xcb, 0x6f, 0x8d, 0xbc, 0xd, 0x62, 0x0, 0x20, 0xf0, 0x18, 0x70,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x20, 0x40, 0x0, 0x0, 0x7f, 0xff, 0xa2, 0x20, 0xa5, 0xa2,
            0x23, 0x25, 0x23, 0xa6, 0xdf, 0x27, 0x9e, 0x25, 0x1d, 0xf6, 0x4c, 0xc6, 0x86, 0xa2,
            0x97, 0xb7, 0x32, 0x84, 0x1a, 0x74, 0x3d, 0xf7, 0xd3, 0xff, 0xd6, 0x1d, 0x10, 0x7a,
            0xa2, 0x1f, 0x25, 0x41, 0x6e, 0x5e, 0x8, 0xc6, 0x16, 0x7d, 0xcd, 0x2c, 0x1e, 0x8d,
            0xfd, 0xe3, 0x5, 0xec, 0x42, 0x19, 0x43, 0xb0, 0x1a, 0x63, 0xe0, 0x7c, 0x71, 0xff,
            0x4d, 0xad, 0xfe, 0xab, 0x4f, 0xd0, 0xcb, 0x7f, 0x54, 0xc8, 0x7, 0xc9, 0x30, 0x20,
            0xb7, 0x60, 0x5e, 0x2a, 0xc1, 0x8b, 0xc3, 0xf9, 0xf6, 0x73, 0xe9, 0x61, 0xe7, 0xe8,
            0x9c, 0x9f, 0xbc, 0x92, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x80, 0x0,
            0x65, 0x56, 0x98, 0x63, 0x5e, 0x98, 0xe7, 0x76, 0x75, 0xe3, 0x74, 0x93, 0x80, 0x6c,
            0x12, 0x9a,
        ];
        assert_eq!(NtripClient::is_valid_rtcm_from_start(&rtcm_msg), Some(144));

        let rtcm_msg = [
            0xd3, 0x0, 0xd1, 0x44, 0x6b, 0x6f, 0x5d, 0x8f, 0xb8, 0xa2, 0x0, 0x20, 0x88, 0x38, 0x14,
            0x10, 0x0, 0x0, 0x0, 0x0, 0x20, 0x1, 0x11, 0x0, 0x7f, 0xff, 0xff, 0xfa, 0x9a, 0x9a,
            0x82, 0xb2, 0x7a, 0xc2, 0xbd, 0xc1, 0x68, 0x75, 0xc4, 0xa4, 0xc5, 0x80, 0xd5, 0xbf,
            0xb1, 0xbf, 0x82, 0xff, 0x2f, 0xfe, 0xf6, 0x0, 0xc, 0x3, 0x98, 0x8, 0x50, 0x19, 0xa6,
            0xb0, 0x4d, 0x24, 0x9a, 0x87, 0x35, 0x7b, 0x80, 0x3f, 0x2, 0x26, 0x9, 0x5c, 0x19, 0xa1,
            0x19, 0xc2, 0x34, 0x4, 0x98, 0x9, 0x87, 0xa4, 0x2b, 0x4f, 0x26, 0xa3, 0x3d, 0x4f, 0x38,
            0xc9, 0x72, 0x13, 0xe4, 0x5c, 0xc9, 0x3d, 0xfe, 0xcc, 0xf, 0xfb, 0xf6, 0x3f, 0xf2,
            0xc9, 0x7f, 0xdd, 0xce, 0x0, 0x10, 0x18, 0x1, 0xcd, 0x80, 0x8, 0x6a, 0x0, 0x34, 0x54,
            0x1a, 0xc1, 0xe0, 0x69, 0xd, 0x21, 0xa8, 0x4, 0x6, 0xaf, 0x27, 0xe0, 0xf, 0x4f, 0x80,
            0xf5, 0x1e, 0x8, 0x7f, 0xf8, 0x31, 0xc, 0x4, 0x6f, 0xd0, 0x11, 0xad, 0x40, 0x49, 0xa5,
            0x81, 0x32, 0x21, 0xe9, 0xd, 0xcf, 0xa7, 0x86, 0x9e, 0xa2, 0xc8, 0x7a, 0x9d, 0xcd,
            0xe3, 0x36, 0x1f, 0x90, 0x82, 0x5e, 0x44, 0xf7, 0xf9, 0x26, 0x82, 0xaa, 0xaa, 0xaa,
            0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x0, 0x0, 0x0, 0x17,
            0xe3, 0xa6, 0x37, 0xe3, 0xa6, 0x36, 0x59, 0x7d, 0x95, 0x59, 0x7d, 0xb5, 0xdf, 0x95,
            0xd7, 0xdb, 0x85, 0xb6, 0x5b, 0x85, 0xa0, 0xa4, 0x5e, 0xa8,
        ];
        assert_eq!(NtripClient::is_valid_rtcm_from_start(&rtcm_msg), Some(215));

        let rtcm_msg = [
            0xd3, 0x0, 0xc8, 0x46, 0x4b, 0x6f, 0x5d, 0x8e, 0xdd, 0xe0, 0x0, 0x20, 0x80, 0x58, 0x16,
            0x0, 0x28, 0x16, 0x0, 0x0, 0x20, 0x82, 0x0, 0x0, 0x7f, 0xf6, 0xdb, 0x6d, 0xa1, 0x14,
            0xd5, 0x14, 0xd3, 0x92, 0x15, 0x12, 0xd5, 0x94, 0x94, 0x29, 0xee, 0x36, 0x6a, 0x3d,
            0x45, 0xf6, 0x89, 0xc2, 0xd7, 0xec, 0xc9, 0x1f, 0xaa, 0xcc, 0x39, 0x95, 0x1b, 0x35,
            0x1, 0x3c, 0x22, 0x7a, 0x65, 0x10, 0x75, 0xef, 0xec, 0xa4, 0xda, 0x8, 0x48, 0xf0, 0x95,
            0x10, 0xc6, 0x91, 0x8a, 0x58, 0x68, 0x30, 0x91, 0x1e, 0x94, 0x3f, 0xe7, 0xc1, 0x1f,
            0x93, 0x1, 0x6, 0x22, 0x2b, 0xd9, 0x36, 0x32, 0x52, 0x1b, 0x98, 0x36, 0x1b, 0xe6, 0x1e,
            0x3f, 0x95, 0x11, 0x1e, 0x69, 0x79, 0x4, 0xf2, 0x7a, 0x13, 0xcb, 0x58, 0x50, 0xd8,
            0xbe, 0xbd, 0xb7, 0xfb, 0x24, 0x77, 0xec, 0xfd, 0xa8, 0x48, 0xe8, 0x1, 0x2a, 0x4e,
            0x83, 0x1a, 0xe8, 0xc, 0x4c, 0xbf, 0x86, 0x9f, 0x9e, 0x12, 0x81, 0x7, 0xa3, 0xfe, 0x1f,
            0xf4, 0x6f, 0xc0, 0xf8, 0x5f, 0x26, 0x4d, 0x84, 0x17, 0xb6, 0x11, 0x56, 0xcf, 0x93,
            0x4f, 0x1e, 0x4a, 0x2b, 0x86, 0xe7, 0x5a, 0x1b, 0xc, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
            0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x80, 0x0, 0x0, 0x2b, 0xae, 0x8b, 0x6c,
            0xba, 0x7a, 0xab, 0xc6, 0xfc, 0xb2, 0xd3, 0x4b, 0x2b, 0xcf, 0x4a, 0xe9, 0xb6, 0xcc,
            0x30, 0x19, 0xbb, 0x92,
        ];
        assert_eq!(NtripClient::is_valid_rtcm_from_start(&rtcm_msg), Some(206));
    }

    #[test]
    fn test_extract_rtcm_messages() {
        let buf = vec![
            0xd3, 0x0, 0xe2, 0x43, 0x2b, 0x6f, 0x5d, 0x8f, 0xb8, 0xa2, 0x0, 0x20, 0x8f, 0x50, 0x88,
            0x2, 0x0, 0x0, 0x0, 0x0, 0x20, 0x20, 0x81, 0x0, 0x7f, 0x7f, 0x7f, 0xe6, 0x7a, 0x82,
            0x6a, 0x6a, 0x2a, 0x42, 0x4a, 0x82, 0x2a, 0x41, 0xa8, 0xa7, 0xcc, 0xff, 0x51, 0x66,
            0x80, 0xba, 0xdc, 0xc7, 0x67, 0xf6, 0x3f, 0xf4, 0x97, 0xea, 0xaf, 0xea, 0x9e, 0x32,
            0x7c, 0x5b, 0xf8, 0xe7, 0xde, 0x87, 0xc2, 0x4f, 0x86, 0x77, 0xc, 0xb3, 0xe8, 0xe7,
            0xc7, 0xcf, 0x9a, 0xfe, 0xdf, 0xfe, 0xed, 0xfe, 0x33, 0xfc, 0xe, 0x80, 0x3c, 0xfe,
            0x9a, 0x4, 0xf4, 0x6c, 0x7c, 0xa6, 0xfa, 0x49, 0xd3, 0x37, 0xa5, 0x60, 0x21, 0x40,
            0x51, 0x20, 0xad, 0x41, 0x45, 0xff, 0x65, 0xf1, 0xfe, 0x90, 0x3f, 0xfa, 0x3f, 0xdf,
            0xf4, 0xc0, 0xfe, 0x32, 0x15, 0xf8, 0xb5, 0x17, 0xe2, 0xd4, 0x7e, 0xf4, 0xc, 0xfc,
            0x24, 0x4d, 0xf0, 0x91, 0x17, 0xc3, 0x10, 0xc1, 0xf4, 0x19, 0x7, 0xc8, 0xc8, 0x1f,
            0x23, 0x5f, 0xfb, 0x74, 0xff, 0xf7, 0x26, 0x7f, 0xdc, 0x93, 0xff, 0x83, 0x7, 0xa0,
            0x12, 0xfe, 0x7f, 0x1f, 0x79, 0xfc, 0x7d, 0xe8, 0xd7, 0xe7, 0xf2, 0x83, 0xbf, 0xd2,
            0x2c, 0x7d, 0x34, 0x67, 0xf4, 0xaa, 0xa0, 0x8, 0x45, 0x40, 0x28, 0x57, 0x0, 0xa1, 0x6e,
            0x2, 0x86, 0xea, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
            0xaa, 0xaa, 0xaa, 0xa8, 0x0, 0x0, 0x0, 0x15, 0xb7, 0x3c, 0xf7, 0x41, 0x3d, 0xb5, 0xd5,
            0x7e, 0x19, 0xdd, 0x86, 0x56, 0xe9, 0x84, 0xb6, 0xe5, 0x42, 0x97, 0xcd, 0x8e, 0x56,
            0xe6, 0x78, 0xa6, 0xb9, 0x0, 0x0, 0x0, 0xd3, 0x0, 0x8a, 0x43, 0xcb, 0x6f, 0x8d, 0xbc,
            0xd, 0x62, 0x0, 0x20, 0xf0, 0x18, 0x70, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20, 0x40, 0x0, 0x0,
            0x7f, 0xff, 0xa2, 0x20, 0xa5, 0xa2, 0x23, 0x25, 0x23, 0xa6, 0xdf, 0x27, 0x9e, 0x25,
            0x1d, 0xf6, 0x4c, 0xc6, 0x86, 0xa2, 0x97, 0xb7, 0x32, 0x84, 0x1a, 0x74, 0x3d, 0xf7,
            0xd3, 0xff, 0xd6, 0x1d, 0x10, 0x7a, 0xa2, 0x1f, 0x25, 0x41, 0x6e, 0x5e, 0x8, 0xc6,
            0x16, 0x7d, 0xcd, 0x2c, 0x1e, 0x8d, 0xfd, 0xe3, 0x5, 0xec, 0x42, 0x19, 0x43, 0xb0,
            0x1a, 0x63, 0xe0, 0x7c, 0x71, 0xff, 0x4d, 0xad, 0xfe, 0xab, 0x4f, 0xd0, 0xcb, 0x7f,
            0x54, 0xc8, 0x7, 0xc9, 0x30, 0x20, 0xb7, 0x60, 0x5e, 0x2a, 0xc1, 0x8b, 0xc3, 0xf9,
            0xf6, 0x73, 0xe9, 0x61, 0xe7, 0xe8, 0x9c, 0x9f, 0xbc, 0x92, 0xaa, 0xaa, 0xaa, 0xaa,
            0xaa, 0xaa, 0xaa, 0xaa, 0x80, 0x0, 0x65, 0x56, 0x98, 0x63, 0x5e, 0x98, 0xe7, 0x76,
            0x75, 0xe3, 0x74, 0x93, 0x80, 0x6c, 0x12, 0x9a, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xd3, 0x0, 0xd1, 0x44, 0x6b, 0x6f, 0x5d, 0x8f, 0xb8,
            0xa2, 0x0, 0x20, 0x88, 0x38, 0x14, 0x10, 0x0, 0x0, 0x0, 0x0, 0x20, 0x1, 0x11, 0x0,
            0x7f, 0xff, 0xff, 0xfa, 0x9a, 0x9a, 0x82, 0xb2, 0x7a, 0xc2, 0xbd, 0xc1, 0x68, 0x75,
            0xc4, 0xa4, 0xc5, 0x80, 0xd5, 0xbf, 0xb1, 0xbf, 0x82, 0xff, 0x2f, 0xfe, 0xf6, 0x0, 0xc,
            0x3, 0x98, 0x8, 0x50, 0x19, 0xa6, 0xb0, 0x4d, 0x24, 0x9a, 0x87, 0x35, 0x7b, 0x80, 0x3f,
            0x2, 0x26, 0x9, 0x5c, 0x19, 0xa1, 0x19, 0xc2, 0x34, 0x4, 0x98, 0x9, 0x87, 0xa4, 0x2b,
            0x4f, 0x26, 0xa3, 0x3d, 0x4f, 0x38, 0xc9, 0x72, 0x13, 0xe4, 0x5c, 0xc9, 0x3d, 0xfe,
            0xcc, 0xf, 0xfb, 0xf6, 0x3f, 0xf2, 0xc9, 0x7f, 0xdd, 0xce, 0x0, 0x10, 0x18, 0x1, 0xcd,
            0x80, 0x8, 0x6a, 0x0, 0x34, 0x54, 0x1a, 0xc1, 0xe0, 0x69, 0xd, 0x21, 0xa8, 0x4, 0x6,
            0xaf, 0x27, 0xe0, 0xf, 0x4f, 0x80, 0xf5, 0x1e, 0x8, 0x7f, 0xf8, 0x31, 0xc, 0x4, 0x6f,
            0xd0, 0x11, 0xad, 0x40, 0x49, 0xa5, 0x81, 0x32, 0x21, 0xe9, 0xd, 0xcf, 0xa7, 0x86,
            0x9e, 0xa2, 0xc8, 0x7a, 0x9d, 0xcd, 0xe3, 0x36, 0x1f, 0x90, 0x82, 0x5e, 0x44, 0xf7,
            0xf9, 0x26, 0x82, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
            0xaa, 0xaa, 0xaa, 0x0, 0x0, 0x0, 0x17, 0xe3, 0xa6, 0x37, 0xe3, 0xa6, 0x36, 0x59, 0x7d,
            0x95, 0x59, 0x7d, 0xb5, 0xdf, 0x95, 0xd7, 0xdb, 0x85, 0xb6, 0x5b, 0x85, 0xa0, 0xa4,
            0x5e, 0xa8, 0x0, 0xd3, 0x0, 0xc8, 0x46, 0x4b, 0x6f, 0x5d, 0x8e, 0xdd, 0xe0, 0x0, 0x20,
            0x80, 0x58, 0x16, 0x0, 0x28, 0x16, 0x0, 0x0, 0x20, 0x82, 0x0, 0x0, 0x7f, 0xf6, 0xdb,
            0x6d, 0xa1, 0x14, 0xd5, 0x14, 0xd3, 0x92, 0x15, 0x12, 0xd5, 0x94, 0x94, 0x29, 0xee,
            0x36, 0x6a, 0x3d, 0x45, 0xf6, 0x89, 0xc2, 0xd7, 0xec, 0xc9, 0x1f, 0xaa, 0xcc, 0x39,
            0x95, 0x1b, 0x35, 0x1, 0x3c, 0x22, 0x7a, 0x65, 0x10, 0x75, 0xef, 0xec, 0xa4, 0xda, 0x8,
            0x48, 0xf0, 0x95, 0x10, 0xc6, 0x91, 0x8a, 0x58, 0x68, 0x30, 0x91, 0x1e, 0x94, 0x3f,
            0xe7, 0xc1, 0x1f, 0x93, 0x1, 0x6, 0x22, 0x2b, 0xd9, 0x36, 0x32, 0x52, 0x1b, 0x98, 0x36,
            0x1b, 0xe6, 0x1e, 0x3f, 0x95, 0x11, 0x1e, 0x69, 0x79, 0x4, 0xf2, 0x7a, 0x13, 0xcb,
            0x58, 0x50, 0xd8, 0xbe, 0xbd, 0xb7, 0xfb, 0x24, 0x77, 0xec, 0xfd, 0xa8, 0x48, 0xe8,
            0x1, 0x2a, 0x4e, 0x83, 0x1a, 0xe8, 0xc, 0x4c, 0xbf, 0x86, 0x9f, 0x9e, 0x12, 0x81, 0x7,
            0xa3, 0xfe, 0x1f, 0xf4, 0x6f, 0xc0, 0xf8, 0x5f, 0x26, 0x4d, 0x84, 0x17, 0xb6, 0x11,
            0x56, 0xcf, 0x93, 0x4f, 0x1e, 0x4a, 0x2b, 0x86, 0xe7, 0x5a, 0x1b, 0xc, 0xaa, 0xaa,
            0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x80, 0x0, 0x0, 0x2b,
            0xae, 0x8b, 0x6c, 0xba, 0x7a, 0xab, 0xc6, 0xfc, 0xb2, 0xd3, 0x4b, 0x2b, 0xcf, 0x4a,
            0xe9, 0xb6, 0xcc, 0x30, 0x19, 0xbb, 0x92,
        ];
        let rtcm_messages = NtripClient::extract_rtcm_messages(buf);
        assert!(rtcm_messages.iter().all(|rtcm_msg| rtcm_msg[0] == 0xD3));
        assert_eq!(rtcm_messages.len(), 4);
    }
}
